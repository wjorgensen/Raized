import { Cl } from "@stacks/transactions";
import { SDKOptions, CallFnArgs, DeployContractArgs, TransferSTXArgs, ContractOptions, } from "@hirosystems/clarinet-sdk-wasm";
import { vfs } from "./vfs.js";
const wasmModule = import("@hirosystems/clarinet-sdk-wasm");
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#use_within_json
// @ts-ignore
BigInt.prototype.toJSON = function () {
    return this.toString();
};
export const tx = {
    callPublicFn: (contract, method, args, sender) => ({
        callPublicFn: { contract, method, args, sender },
    }),
    callPrivateFn: (contract, method, args, sender) => ({
        callPrivateFn: { contract, method, args, sender },
    }),
    deployContract: (name, content, options, sender) => ({
        deployContract: { name, content, options, sender },
    }),
    transferSTX: (amount, recipient, sender) => ({
        transferSTX: { amount, recipient, sender },
    }),
};
function parseEvents(events) {
    try {
        // @todo: improve type safety
        return JSON.parse(events).map((e) => {
            const { event, data } = JSON.parse(e);
            if ("raw_value" in data) {
                data.value = Cl.deserialize(data.raw_value);
            }
            return {
                event: event,
                data: data,
            };
        });
    }
    catch (e) {
        console.error(`Fail to parse events: ${e}`);
        return [];
    }
}
function parseTxResponse(response) {
    return {
        result: Cl.deserialize(response.result),
        events: parseEvents(response.events),
    };
}
const getSessionProxy = () => ({
    get(session, prop, receiver) {
        // some of the WASM methods are proxied here to:
        // - serialize clarity values input argument
        // - deserialize output into clarity values
        if (prop === "callReadOnlyFn" || prop === "callPublicFn" || prop === "callPrivateFn") {
            const callFn = (contract, method, args, sender) => {
                const response = session[prop](new CallFnArgs(contract, method, args.map((a) => Cl.serialize(a)), sender));
                return parseTxResponse(response);
            };
            return callFn;
        }
        if (prop === "runSnippet") {
            const runSnippet = (snippet) => {
                const response = session[prop](snippet);
                if (response.startsWith("0x")) {
                    return Cl.deserialize(response);
                }
                else {
                    return response;
                }
            };
            return runSnippet;
        }
        if (prop === "deployContract") {
            const callDeployContract = (name, content, options, sender) => {
                const rustOptions = options
                    ? new ContractOptions(options.clarityVersion)
                    : new ContractOptions();
                const response = session.deployContract(new DeployContractArgs(name, content, rustOptions, sender));
                return parseTxResponse(response);
            };
            return callDeployContract;
        }
        if (prop === "transferSTX") {
            const callTransferSTX = (amount, ...args) => {
                const response = session.transferSTX(new TransferSTXArgs(BigInt(amount), ...args));
                return parseTxResponse(response);
            };
            return callTransferSTX;
        }
        if (prop === "mineBlock") {
            const callMineBlock = (txs) => {
                const serializedTxs = txs.map((tx) => {
                    if (tx.callPublicFn) {
                        return {
                            callPublicFn: {
                                ...tx.callPublicFn,
                                args_maps: tx.callPublicFn.args.map(Cl.serialize),
                            },
                        };
                    }
                    if (tx.callPrivateFn) {
                        return {
                            callPrivateFn: {
                                ...tx.callPrivateFn,
                                args_maps: tx.callPrivateFn.args.map(Cl.serialize),
                            },
                        };
                    }
                    return tx;
                });
                const responses = session.mineBlock(serializedTxs);
                return responses.map(parseTxResponse);
            };
            return callMineBlock;
        }
        if (prop === "getDataVar") {
            const getDataVar = (...args) => {
                const response = session.getDataVar(...args);
                const result = Cl.deserialize(response);
                return result;
            };
            return getDataVar;
        }
        if (prop === "getMapEntry") {
            const getMapEntry = (contract, mapName, mapKey) => {
                const response = session.getMapEntry(contract, mapName, Cl.serialize(mapKey));
                const result = Cl.deserialize(response);
                return result;
            };
            return getMapEntry;
        }
        return Reflect.get(session, prop, receiver);
    },
});
// load wasm only once and memoize it
function memoizedInit() {
    let simnet = null;
    return async (manifestPath = "./Clarinet.toml", noCache = false, options) => {
        if (noCache || !simnet) {
            const module = await wasmModule;
            let sdkOptions = new SDKOptions(!!options?.trackCosts, !!options?.trackCoverage);
            simnet = new Proxy(new module.SDK(vfs, sdkOptions), getSessionProxy());
        }
        // start a new simnet session
        await simnet.initSession(process.cwd(), manifestPath);
        return simnet;
    };
}
export const initSimnet = memoizedInit();
//# sourceMappingURL=index.js.map